\chapter{Preliminaries}
\label{chap:preliminaries}

\todo{TODO add some text here}
\todo{%
    TODO @Florian

    How do I talk about access-complexity?

    \quotes{Access graph in constant time.} vs \quotes{Access graph in constant time-complexity.} vs Landau $O(1)$ vs etc
}

\section{Graphs stored as adjacency-array}
\label{chap:preliminaries:graphs}

    \todo{%
        TODO @Florian

        Table + explanations good enough here?
    }

    Let a street-network be given as a graph $G = (V, E)$ with vertices $V$, edges $E$ and a cost-function $c: E \to \mathbb{R}_+^d$, that returns a cost-vector for each edge $e \in E$, also called multidimensional \glspl{metric} in this thesis.
    Note, that $\mathbb{R}_+^d$ doesn't contain zero, which would, depending on the \gls{metric}, result in bad alternative routes otherwise.
    \Glspl{metric} are also called \glspl{cost} depending on the context.
    The underlying graph-structure is implemented as adjacency-array from~\cite{mehlhorn:algorithms} with some adjustments.
    This data-structure fits well, because it reduces redundancy by optimizes the graph's memory-consumption while accessing the graph can be done in constant or logarithmic time (depending on access via indices or via ids) through indexing-logic.

    For the theory of this thesis, above definitions are sufficient.
    Before the adjacency-array can be explained, the graph has to be slightly redefined, so it can be referred with arrays and indices.
    This makes the explanation easier and is needed for \cref{chap:balancing:implementation}.

    As already mentioned, a graph is defined as $G = (V, E)$ with a cost-function $c: E \to \mathbb{R}_+^d$ mapping every edge to a cost-vector.
    Since $V$ and $E$ are final, let $n := \left| V \right|$ be the number of vertices and $m := \left| E \right|$ be the number of edges.
    Then, the graph's components are redefined and stored as follows.
    \begin{itemize}
        \item[Vertices:]
            For implementation, vertices in $V$ are just ids, which are stored in an array in ascending order.
            The order is needed, because the graph is stored as adjacency-array.
            Besides, the order allows to find the index in logarithmic time.
            However, inside, the graph-implementation works with indices and just users from outside may need to search a node by id.
            So let $V$ be an array of node-ids and $V[i_V]$ be the node-id at node-index $0 \le i_V < n$.
        \item[Edges:]
            Edges are considered to be directed and $E$ is defined as an array of tuples of two vertices, so $E \subseteq V \times V$ is a tuple of node-indices (not node-ids).
            However, the sources and destinations in $E$ are stored in separate arrays, so $E := (S, D)$ and $E[i_E] = (S[i_E], D[i_E])$ is the edge from source in $S$ at edge-index $i_E$ to destination in $D$ at edge-index $i_E$.
            Since the graph is stored as adjacency-array, $E$ is considered to be sorted by source-, then by destination-id, in ascending order.
            Let the respective offset-array for remaining $D$ be $D_{\mathit{offset}}$.
            The creation and use of $D_{\mathit{offset}}$ is explained below.
        \item[\Glspl{metric}:]
            For every edge in $E$, a vector of floats is stored.
            To formalize this, the cost-function is slightly redefined (and duplicated edges are being removed) to have edge-costs being associated as \glspl{metric}.
            Let $C \subset E \times \mathbb{R}_+^d$ be the set of \glspl{metric} and $c$ be the bijective function $c: E \to C$.
            With this definition, $C[i_E]$ can be associated as the cost-vector of the edge $E$ at edge-index $i_E$, where $C$ is stored as two-dimensional array of floats.
    \end{itemize}

    After these definitions, the core of the adjacency-array is basically the creation of the offset-array $D_{\mathit{offset}}$, which then helps accessing the graph's components in constant time.
    For every vertex $v \in V$, the offset-array $D_{\mathit{offset}}$ stores the edge-index $i_E$, where the destinations of $v$ start.
    Here, the sorted $E$ is needed.
    This is demonstrated in \cref{table:preliminaries:offset-array} and explained below.

    \begin{table}[htbp]
        \centering
        \begin{tabular}{ l || c | c c c | c c c | c c c | c c | c }
            Vertices $V$ or sources $S$ & 0 & \multicolumn{3}{c |}{1} & \multicolumn{3}{c |}{2} & \multicolumn{3}{c |}{3} & \multicolumn{2}{c |}{4} & - \\
            \hline
            Destinations $D$ & 1 & 0 & 2 & 3 & 1 & 3 & 4 & 1 & 2 & 4 & 2 & 3 & - \\
            \hline
            Offsets $D_{\mathit{offset}}$ & 0 & \multicolumn{3}{c |}{1} & \multicolumn{3}{c |}{4} & \multicolumn{3}{c |}{7} & \multicolumn{2}{c |}{10} & 12 \\
        \end{tabular}
        \caption[Example-graph stored as offset-array]{%
            A graph with $|V| = 5$ and $|E| = 12$ stored as adjacency-array, shown with the respective offset-array.
            Every edge is directed and represents a tuple of source- and destination-vertex.
            All destinations of source $V[s=3] = 3$ are in $D$ between positions $D_{\mathit{offset}}[s] = 7$ (including) and $D_{\mathit{offset}}[s+1] = 10$ (excluding).
            \label{table:preliminaries:offset-array}
        }
    \end{table}

    Let $e = E[i_E] = (S[i_E], D[i_E]) = (s, d)$ be an edge at position $i_E$ and $s$ be the position of the edge's source in $V$.
    Because the edges are sorted by source, than by destination, all edges starting in $V[s]$ are in $D$ between positions $D_{\mathit{offset}}[s]$ (including) and $D_{\mathit{offset}}[s+1]$ (excluding).
    Since every edge-data can be stored according to the edges' destinations $D$ (like \glspl{metric} from $C$), this allows quick access to all relevant edge-components by simply providing the edge-index while keeping the memory-usage low.
    Besides that, it can be extended quite easily, as it is done in \cref{chap:balancing:implementation}.

\section{Contraction-hierarchies}

    \todo{TODO Write}

    \subsection{Overview}

        \todo{TODO Write}

    \subsection{Computing shortcuts of multiple \glspl{metric} with LP/ILP (TODO title)}

        \todo{TODO Write}

\section{Dijkstra's algorithm (bidirectional) in contracted graphs}

    \todo{TODO Write}

    \subsection{Correctness-proof of bidirectional Dijkstra}

        \todo{TODO Remove proof if not needed in the thesis (probably not needed).}

        \todo{
            TODO The termination of the bidirectional Astar is based on the first node v, that is marked by both, the forward- and the backward-subroutine.
            However, this common node v is part of the shortest path s->t wrt to this particular hop-distance H, but doesn't have to be part of the shortest path s->t wrt to \glspl{weight}.

            Every node, that is not settled in any of the both subroutines, has a longer distance to both s and t than the already found common node v and hence can not be part of the shortest path (wrt to \glspl{weight}).
            Otherwise, it would have been settled before v since the priority-queues sort by \glspl{weight}.
            In other words, only already settled nodes and their neighbors (which are already enqueued) can be part of the shortest path.

            In conclusion, emptying the remaining nodes in the queues and picking the shortest path of the resulting common nodes leads to the shortest path wrt to \glspl{weight} from s to t.
        }

        \todo{%
            TODO extend proof onto A* with \gls{contraction-hierarchies}: Here, the proof for bidirectional \gls{dijkstra} doesn't hold, because each sub-graph doesn't visit every node of the total graph, due to the level-filter when pushing edges to the queue.
            Hence, the forward- and the backward-query are not balanced wrt \glspl{weight}.
            Thus, after finding the first meeting-node, the hop-distance of the shortest-path could be arbitrary.
            This leads to wrong paths with normal bidirectional \gls{dijkstra}.
            To correct this issue, stop the query after polling a node of a sub-distance, which is higher than the currently best meeting-node's total distance.
        }

\section{(Restricted) Enumerating personalized routing}

    \todo{TODO acronym (R)EPR and link to Barth's paper(s)}
    \todo{TODO \gls{repr} is just a runtime-optimization of \gls{epr}}
    \todo{TODO Routes within a certain tolerance of the best possible \gls{cost} (per \gls{metric}, \eg\ duration must be not worse than $25~\%$ \todo{tolerance should match the resulting plots}) are randomly chosen from cyclops.}

    \subsection{Idea}

        \todo{TODO write; Here could be talked about the approach of removing the nd-triangulation and how cyclops takes this idea/context and makes it correct by building convex-hull explicitly (because new facets could destroy old facets).}