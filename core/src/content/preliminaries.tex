\chapter{Preliminaries}
\label{chap:preliminaries}

\todo{TODO add some text here}

\section{Graphs stored as adjacency-array}
\label{chap:preliminaries:graphs}

    Let a street-network be given as a graph $G = (V, E)$ with vertices $V$, edges $E$ and a cost-function $c: E \to \mathbb{R}_+^d$, that returns a cost-vector for each edge $e \in E$, also called multidimensional \glspl{metric} in this thesis.
    \Glspl{metric} are also called \glspl{cost} depending on the context.

    For the theory of this thesis, above definitions are sufficient.
    However, the implementation-details in \cref{chap:balancing:implementation} concretize the graph to store it efficiently.
    The underlying graph's data-structure is based on the idea of adjacency-arrays, which is mentioned in~\cite{mehlhorn:algorithms}.
    For this reason, this brief idea is extended both in the following to demonstrate the brief idea and in \cref{chap:balancing:implementation}.

    Before the adjacency-array can be concretized, the graph has to be slightly redefined, so it can be referred with arrays and indices.
    Again, this is not needed for the theory in this thesis, but makes the explanation of adjacency-arrays easier and is needed in the implementation-details in \cref{chap:balancing:implementation}.

    As already mentioned, a graph is defined as $G = (V, E)$ with a cost-function $c: E \to \mathbb{R}_+^d$ mapping every edge to a cost-vector.
    Since $V$ and $E$ are finite, let $n := \left| V \right|$ be the number of vertices and $m := \left| E \right|$ be the number of edges.
    Then, the graph's components are interpreted and stored as follows.
    \begin{itemize}
        \item[Vertices:]
            For implementation, vertices in $V$ are just ids, which are stored in an array in ascending order.
            The order is needed for accessing the graph's data later.
            So let $V$ be an array of node-ids and $V[i_V]$ be the node-id at node-index $0 \le i_V < n$.
        \item[Edges:]
            Edges are considered to be directed and $E$ is defined as an array of tuples of two vertex-indices, so $E \subseteq \left\{ 0, 1, \dots, n-1 \right\}^2$.
            However, the sources and destinations in $E$ are stored in separate arrays, so $E := (S, D)$ and $E[i_E] = (S[i_E], D[i_E])$ is the edge from source-index in $S$ at edge-index $i_E$ to destination-index in $D$ at edge-index $i_E$.
            Since the graph is stored as adjacency-array, $E$ is considered to be sorted by source-, then by destination-id (although node-indices are stored in $S$ and $D$), in ascending order.
            Let the respective offset-array for remaining $D$ be $O_D$.
            The creation and use of $O_D$ is explained below.$S$
            With the interpretation of the offset-array, storing $S$ will not be necessary, because $S$ (without duplicates) will be $[0, 1, \dots, n-1]$ and thus match $V$.
    \end{itemize}

    After these definitions, the core of the adjacency-array is basically the creation of the offset-array $O_D$, which then helps accessing the graph's components in constant time.
    For every vertex $v \in V$, the offset-array $O_D$ stores the edge-index $i_E$, where the leaving edge starting in $v$ occurs.
    Here, the sorted $E$ is needed.
    This is demonstrated in \cref{table:preliminaries:offset-array} and explained below.

    \begin{table}[htbp]
        \centering
        \begin{tabular}{ l || c | c c c | c c c | c c c | c c | c }
            Vertices $V$ or sources $S$ & 0 & \multicolumn{3}{c |}{1} & \multicolumn{3}{c |}{2} & \multicolumn{3}{c |}{3} & \multicolumn{2}{c |}{4} & - \\
            \hline
            Destinations $D$ & 1 & 0 & 2 & 3 & 1 & 3 & 4 & 1 & 2 & 4 & 2 & 3 & - \\
            Offsets $O_D$ & 0 & \multicolumn{3}{c |}{1} & \multicolumn{3}{c |}{4} & \multicolumn{3}{c |}{7} & \multicolumn{2}{c |}{10} & 12 \\
        \end{tabular}
        \caption[Example-graph stored as offset-array]{%
            A graph with $|V| = 5$ and $|E| = 12$ stored as adjacency-array, shown with the respective offset-array.
            Every edge in the graph is bidirectional, but stored directed and represents as a tuple of source- and destination-vertex.
            All destinations of leaving edges starting in $V[s=3] = 3$ are in $D$ between positions $O_D[s] = 7$ (including) and $O_D[s+1] = 10$ (excluding).
            \label{table:preliminaries:offset-array}
        }
    \end{table}

    Let $e = E[i_E] = (S[i_E], D[i_E]) = (s, d)$ be an edge at position $i_E$ and $s$ be the position of the edge's source in $V$.
    Because the edges are sorted by source, than by destination, all edges starting in $V[s]$ are in $D$ between positions $O_D[s]$ (including) and $O_D[s+1]$ (excluding).
    Since every edge-data can be stored according to the edges' destinations $D$ (like \glspl{metric}), this allows quick access to all relevant edge-components by simply providing the edge-index while keeping the memory-usage low.
    Besides that, it can be extended quite easily and complex, as it is done in \cref{chap:balancing:implementation}.

\section{Contraction-hierarchies}

    \todo{TODO Write}

    \subsection{Overview}

        \todo{TODO Write}

    \subsection{Computing shortcuts of multiple \glspl{metric} with LP/ILP (TODO title)}

        \todo{TODO Write}

\section{Dijkstra's algorithm (bidirectional) in contracted graphs}

    \todo{TODO Write}

    \subsection{Correctness-proof of bidirectional Dijkstra}

        \todo{TODO Remove proof if not needed in the thesis (probably not needed).}

        \todo{
            TODO The termination of the bidirectional Astar is based on the first node v, that is marked by both, the forward- and the backward-subroutine.
            However, this common node v is part of the shortest path s->t wrt to this particular hop-distance H, but doesn't have to be part of the shortest path s->t wrt to \glspl{weight}.

            Every node, that is not settled in any of the both subroutines, has a longer distance to both s and t than the already found common node v and hence can not be part of the shortest path (wrt to \glspl{weight}).
            Otherwise, it would have been settled before v since the priority-queues sort by \glspl{weight}.
            In other words, only already settled nodes and their neighbors (which are already enqueued) can be part of the shortest path.

            In conclusion, emptying the remaining nodes in the queues and picking the shortest path of the resulting common nodes leads to the shortest path wrt to \glspl{weight} from s to t.
        }

        \todo{%
            TODO extend proof onto A* with \gls{contraction-hierarchies}: Here, the proof for bidirectional \gls{dijkstra} doesn't hold, because each sub-graph doesn't visit every node of the total graph, due to the level-filter when pushing edges to the queue.
            Hence, the forward- and the backward-query are not balanced wrt \glspl{weight}.
            Thus, after finding the first meeting-node, the hop-distance of the shortest-path could be arbitrary.
            This leads to wrong paths with normal bidirectional \gls{dijkstra}.
            To correct this issue, stop the query after polling a node of a sub-distance, which is higher than the currently best meeting-node's total distance.
        }

\section{(Restricted) Enumerating personalized routing}

    \todo{TODO acronym (R)EPR and link to Barth's paper(s)}
    \todo{TODO \gls{repr} is just a runtime-optimization of \gls{epr}}
    \todo{TODO Routes within a certain tolerance of the best possible \gls{cost} (per \gls{metric}, \eg\ duration must be not worse than $25~\%$ \todo{tolerance should match the resulting plots}) are randomly chosen from cyclops.}

    \subsection{Idea}

        \todo{TODO write; Here could be talked about the approach of removing the nd-triangulation and how cyclops takes this idea/context and makes it correct by building convex-hull explicitly (because new facets could destroy old facets).}